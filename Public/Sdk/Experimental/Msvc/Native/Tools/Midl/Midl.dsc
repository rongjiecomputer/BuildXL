// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

import {Artifact, Cmd, Tool, Transformer} from "Sdk.Transformers";

import {Shared, PlatformDependentQualifier} from "Sdk.Native.Shared";

import * as Cl from "Sdk.Native.Tools.Cl";

export declare const qualifier: PlatformDependentQualifier;

/** All the Idl output flags for COM */
@@public
export const idlOutputsCom: IdlOutputs = IdlOutputs.comProxy | IdlOutputs.comProxyEntries | IdlOutputs.comUuidConstants | IdlOutputs.oleAutomationTypeLibrary;

/** All the Idl output flags for WinRt */
@@public
export const idlOutputsWinRt: IdlOutputs = IdlOutputs.winRtMetadata;

/** All the Idl output flags for RPC */
@@public
export const idlOutputsRpc: IdlOutputs = IdlOutputs.rpcClient | IdlOutputs.rpcServer;

/**
 * An input file with optional overrides.
 */
@@public
export interface MidlFile extends Shared.SourceFileContainer {
    /**
     * Allows the specification to override the output index key.
     * There are cases where the same input file is processed multiple times and the default key of the
     * source file, is insufficient to find the result.
     */
    outputKey?: PathAtom;

    /** The Application Configuration File to match with the IDL source file. */
    @@Tool.option("/acf")
    applicationConfigurationFile?: File;

    /** The dlldata file name which contains the entry points and data structures required by the class factory for the proxy DLL. */
    @@Tool.option("/dlldata", { optionSeparator: " " })
    comProxyEntriesFileName?: PathAtom;

    /** The name of the interface proxy file for a COM interface. */
    @@Tool.option("/proxy", { optionSeparator: " " })
    comProxyFileName?: PathAtom;

    /**
     * The name of the OLE interface UUID file.
     * Include/Compile the Universal Unique Identifiers file.
     */
    @@Tool.option("/iid", { optionSeparator: " " })
    comUuidFileName?: PathAtom;

    /** The name used for header file. */
    @@Tool.option("/header", { optionSeparator: " " })
    headerFileName?: PathAtom;

    /** The OLE automation type library file name. */
    @@Tool.option("/tlb", { optionSeparator: " " })
    oleTypeLibraryFileName?: PathAtom;

    /** The name of the client-side C source file for an RPC interface. */
    @@Tool.option("/cstub", { optionSeparator: " " })
    rpcClientFileName?: PathAtom;

    /** The name of the server-side C source file for an RPC interface. */
    @@Tool.option("/sstub", { optionSeparator: " " })
    rpcServerFileName?: PathAtom;

    /** The name used for output WinRt metadata file. */
    @@Tool.option("/winmd")
    winRtMetadataFileName?: PathAtom;
}

/**
 * Midl-specific context for each Midl evaluation
 */
interface MidlEvaluationContext {
    /** Output header file associated with this context */
    headerFile?: Path;
    /** Output proxy file associated with this context */
    proxyFile?: Path;
    /** Output client stub file associated with this context */
    clientStubFile?: Path;
    /** Output server stub file associated with this context */
    serverStubFile?: Path;
    /** Output dll data file associated with this context */
    dllDataFile?: Path;
    /** Output iid file associated with this context */
    iidFile?: Path;
    /** Output type library file associated with this context */
    typeLibraryFile?: Path;
    /** Output mef file associated with this context */
    mefFile?: Path;
    /** Output winRt metadata file associated with this context */
    winRtMetadataFile?: Path;
}

/**
 * Arguments for MIDL transformer
 */
@@public
export interface Arguments extends Transformer.RunnerArguments {
    /** Allows control of what MIDL will use for char and small types. */
    charBaseType?: CharBaseType;

    /** Controls whether or not a comment appears in the header echoing the compilation flags. */
    @@Tool.option("/no_settings_comment")
    compilerSettingsComment?: boolean;

    /** Controls the C preprocessing performed on the input IDL files. */
    @@Tool.option("/no_cpp", { negateOption: true })
    cPreprocessing?: boolean;

    /** The name of C preprocessor (default: cl.exe) to use. */
    @@Tool.option("/cpp_cmd", { optionSeparator: ' ' })
    cPreprocessor?: Transformer.ToolDefinition;

    /** Global behavior with regards to the enable_allocate attribute. */
    enableAllocateBehavior?: EnableAllocateBehavior;

    /** Rename the intermediate file generated by WinRT */
    @@Tool.option("/idl_file")
    idlFile?: PathAtom;

    /** The files that are co-located with the source and included or imported. */
    includesAndImports?: File[];

    /** Use or ignore the source IDL directory implicitly in the include search. */
    includeSearchPathBehavior?: IncludeSearchPathBehavior;

    /** Directories that are searched for include files. */
    @@Tool.option("/I")
    includeSearchPaths?: StaticDirectory[];

    /** Locale identifier hint to allow MIDL to correctly interpret DBCS characters in comments, helpstrings and identifiers. */
    @@Tool.option("/lcid", { optionSeparator: " " })
    inputLocaleId?: number;

    /** The autogeneration behavior for interface names. */
    interfaceNameBehavior?: InterfaceNameBehavior;

    /**
     * Declares the type of content expressed in the source file.
     * Interface definition language (IDL) files can be used to express multiple types of contracts.  From Object Linking and Embedding (OLE) to WinRT interfaces.
     * Since the set of files produce by the tool are different, the correct type must be selected to correctly track which output files will be generated.
     */
    interfaceType: InterfaceType;

    /** The marshaling optimization to produce for the client and server stubs. */
    marshalingOptimization?: MarshalingOptimization;

    /**
     * Dictates if MIDL is to create .MEF files for the IDLs it compiles.
     * InternalThe MEF file is used for OACR checks of errors, and also by various fuzzing tools to attack RPC interfaces.
     */
    @@Tool.option("/export")
    mefFileGeneration?: boolean;

    /** A hint to the minimum operating system that the stubs will run on and thus the optimizations that can be applied. */
    minimumTargetOperatingSystem?: MinimumTargetOperatingSystem;

    /**
     * Generate additional error-checking information that can be used by the NDR engine to perform integrity checks at run time.
     * Defaults to Robust on Windows 2000 and later.
     */
    networkDataRepresentationRuntimeChecking?: NetworkDataRepresentationRuntimeChecking;

    /**
     * Tells Midl to not generate headers or create proxy/stub files.
     */
    @Tool.option("/nomidl")
    noMidl?: boolean;

    /** The NDR alignment behavior for non-encapsulated unions. */
    nonEncapsulatedUnionBehavior?: NonEncapsulatedUnionBehavior;

    /** Dictates the operation mode of the Midl engine. */
    operatingMode?: OperatingMode;

    /** The additional C preprocessor options */
    @@Tool.option("/cpp_opt")
    preprocessorOptions?: string[];

    /** Specifies a list of one or more preprocessing symbols. */
    @@Tool.option("/D", { optionSeparator: " " })
    preprocessorSymbols?: Shared.PreprocessorSymbol[];

    /**
     * What output files to produce.
     * [DefaultValue(IdlOutputs.Header)]
     */
    produce: IdlOutputs;

    /** The string to prefix client-side entry points (functions). */
    @@Tool.option("/prefix client")
    rpcClientFunctionsPrefix?: string;

    /** String to prefix all entry functions on the client and server stubs. */
    @@Tool.option("/prefix all")
    rpcFunctionsPrefix?: string;

    /** Control over how the server stub routes function calls to an implementation. */
    rpcServerEntryRoutingMethod?: ServerStubEntryPoint;

    /** The string to prefix server-side entry points (functions). */
    @@Tool.option("/prefix server")
    rpcServerFunctionsPrefix?: string;

    /** Specifies a list of source files to be processed. */
    sources: MidlFile[];

    /** Options to generate Static analysis annotations on generated code and prototypes. */
    staticAnalysisOptions?: StaticAnalysisOption;

    /** Controls the boundary for struct member alignment. */
    structMemberAlignment?: MidlStructMemberAlignment;

    /** The wire protocol supported by the generated stub. */
    stubWireProtocol?: StubWireProtocol;

    /** Suppresses the display of the sign-on banner when the compiler starts up and display of informational messages during compilation. */
    @@Tool.option("/nologo")
    suppressStartupBanner?: boolean;

    /** String to prefix all switch routine prototypes. */
    @@Tool.option("/prefix switch")
    switchRoutinesPrefix?: string;

    /** The destination target environment for the type library and stub files. */
    targetEnvironment?: MidlTargetEnvironment;

    /** Controls whether or not a comment appears in the header with the compilation timestamp. */
    @@Tool.option("/no_stamp")
    timestampComment?: boolean;

    /** Treats all the warnings as errors based on the current WarningLevel. */
    @@Tool.option("/WX")
    treatWarningsAsErrors?: boolean;

    /** Optimization settings for type and procedure descriptors. */
    typeAndProcedureOptimization?: TypeAndProcedureOptimization;

    /** Specifies a list of one or more preprocessor symbols to undefine. */
    @@Tool.option("/U", { optionSeparator: " " })
    undefinePreprocessorSymbols?: string[];

    /** Control over the type used for int_ptr within Variants. */
    variantIntPtrType?: IntPtrType;

    /** Determines how strict the compiler should be about warnings. */
    warningLevel?: MidlWarningLevel;

    /** Code generation options specific to WinRt. */
    winRtCodeGeneration?: WinRtCodeGeneration;

    /** Specify one or more directories containing WinRt metadata files. */
    @@Tool.option("/metadata_dir")
    winRtMetadataDir?: StaticDirectory[];
}

/** The default MIDL arguments */
export const defaultMidlArguments: Arguments = {
    sources: [],
    charBaseType: CharBaseType.defaultOption,
    compilerSettingsComment: false,
    cPreprocessing: true,
    enableAllocateBehavior: EnableAllocateBehavior.defaultOption,
    includesAndImports: [],
    includeSearchPathBehavior: IncludeSearchPathBehavior.defaultOption,
    includeSearchPaths: [],
    inputLocaleId: 0,
    interfaceNameBehavior: InterfaceNameBehavior.defaultOption,
    interfaceType: InterfaceType.ole,
    marshalingOptimization: MarshalingOptimization.codeless,
    mefFileGeneration: false,
    minimumTargetOperatingSystem: MinimumTargetOperatingSystem.nt60,
    networkDataRepresentationRuntimeChecking: NetworkDataRepresentationRuntimeChecking.robust,
    noMidl: false,
    nonEncapsulatedUnionBehavior: NonEncapsulatedUnionBehavior.defaultOption,
    operatingMode: OperatingMode.defaultOption,
    preprocessorOptions: [],
    preprocessorSymbols: [],
    produce: IdlOutputs.header,
    rpcServerEntryRoutingMethod: ServerStubEntryPoint.staticFunctions,
    staticAnalysisOptions: StaticAnalysisOption.none,
    structMemberAlignment: MidlStructMemberAlignment.align8,
    stubWireProtocol: StubWireProtocol.all,
    suppressStartupBanner: true,
    targetEnvironment: MidlTargetEnvironment.win32,
    timestampComment: false,
    treatWarningsAsErrors: true,
    typeAndProcedureOptimization: TypeAndProcedureOptimization.foldDuplicates,
    undefinePreprocessorSymbols: [],
    variantIntPtrType: IntPtrType.defaultOption,
    warningLevel: MidlWarningLevel.level1,
    winRtCodeGeneration: WinRtCodeGeneration.empty,
    winRtMetadataDir: []
};

/**
 * The Midl state that is passed around.
 * Because TypeScript doesn't have global variables or static classes we need to pass the arguments around.
 */
interface MidlRunnerState {
    /** The transformer execution arguments */
    executeArguments: Transformer.ExecuteArguments;

    /** Midl evaluation context */
    midlContext: MidlEvaluationContext;

    /** Output directory */
    outputDirectory?: Directory;

    /** The dll data file */
    dllData?: File;
}

/**
 * Merge two MidlRunnerStates.
 * Overrides the midlContext and merges both execute arguments. Everything else is left untouched.
 */
function mergeMidlRunnerStates(midlRunnerState1: MidlRunnerState, midlRunnerState2: MidlRunnerState): MidlRunnerState {
    return midlRunnerState1.override<MidlRunnerState>({
        executeArguments: midlRunnerState2.executeArguments,
        midlContext: midlRunnerState1.midlContext.override<MidlEvaluationContext>(midlRunnerState2.midlContext)
    });
}

/**
 * Default tool
 */
export function defaultTool(): Transformer.ToolDefinition {
    Contract.fail("No default tool was provided");
    return undefined;
}

@@public
export function midlFile(
    f: File, 
    obj?: {
        outputKey?: PathAtom,
        applicationConfigurationFile?: File,
        comProxyEntriesFileName?: PathAtom,
        comProxyFileName?: PathAtom,
        comUuidFileName?: PathAtom,
        headerFileName?: PathAtom,
        oleTypeLibraryFileName?: PathAtom,
        rpcClientFileName?: PathAtom,
        rpcServerFileName?: PathAtom,
        winRtMetadataFileName?: PathAtom
    }): MidlFile {
    return <MidlFile>{
        source: f,
    }.override<MidlFile>(obj);
}

/**
 * The value produced by MidlRunner per input idl file.
 */
@@public
export interface Result {
    /** Client stub C file. */
    clientStub?: File;

    /** Client stub DllData C file. */
    dllData?: File;

    /** Interface/RPC C header file. */
    header?: StaticDirectory;

    /** Interface IID file. */
    iid?: File;

    /**
     * Interface/RPC MEF file.
     * Internal
     */
    mef?: File;

    /** Data/marshaling Proxy C file. */
    proxy?: File;

    /** Server stub C file. */
    serverStub?: File;

    /** Interface type library file. */
    typeLibrary?: File;
    
    /** .winmd file. */
    winRtMetadata?: File;

    /** Returns the client C files */
    client?: File[];

    /** Returns the server C files */
    server?: File[];
}

/**
 * Transformer for running MIDL.exe
 */
@@Tool.runner("midl.exe")
@@public
export function evaluate(args: Arguments): Map<PathAtom, Result> {
    args = defaultMidlArguments.override<Arguments>(args);

    // We supply the default cPreprocessor tool here, rather than in
    // defaultMidlArguments, because we should only attempt to evaluate
    // Cl.defaultTool() if we actually need to determine the default tool. 
    if (args.cPreprocessor === undefined) {
        args = args.override<Arguments>({
            cPreprocessor: importFrom("VisualCpp").clTool,
        });
    }
    let midlDllData: File = undefined;
    let results = Map.empty<PathAtom, Result>();

    for (let midlFile of args.sources) {
        let argumentsEvaluation = evaluateArgs(args, midlFile, midlDllData);

        let outputs = Transformer.execute(argumentsEvaluation.executeArguments);

        let result = postFinishPip(midlFile, argumentsEvaluation.midlContext, outputs);

        if (argumentsEvaluation.midlContext !== undefined) {
            midlDllData = outputs.getOutputFile(argumentsEvaluation.midlContext.dllDataFile);
        }

        let keyName = (midlFile !== undefined && midlFile.outputKey !== undefined
                    ? midlFile.outputKey
                    : midlFile.source.name);

        results = results.add(keyName, result);
    }

    return results;
}

/** Get outputs */
function postFinishPip(midlFile: MidlFile, midlContext: MidlEvaluationContext, outputs: Transformer.ExecuteResult): Result {
    let includeDirectory: StaticDirectory = undefined;
    if (midlContext.headerFile !== undefined) {
        includeDirectory = Transformer.sealPartialDirectory(d`${midlContext.headerFile.parent}`, [ outputs.getOutputFile(midlContext.headerFile) ]);
    }

    let proxy         = outputs.getOutputFile(midlContext.proxyFile);
    let clientStub    = outputs.getOutputFile(midlContext.clientStubFile);
    let serverStub    = outputs.getOutputFile(midlContext.serverStubFile);
    let dllData       = outputs.getOutputFile(midlContext.dllDataFile);
    let iid           = outputs.getOutputFile(midlContext.iidFile);
    let typeLibrary   = outputs.getOutputFile(midlContext.typeLibraryFile);
    let mef           = outputs.getOutputFile(midlContext.mefFile);
    let winRtMetadata = outputs.getOutputFile(midlContext.winRtMetadataFile);

    let output: Result = {
        // Generic headers
        header: includeDirectory,
        
        // RPC Outputs
        clientStub: clientStub,
        serverStub: serverStub,

        // OLE/COM outputs
        proxy: proxy,
        dllData: dllData,
        iid: iid,
        typeLibrary: typeLibrary,

        // WinRT outputs
        winRtMetadata: winRtMetadata,

        mef: mef,

        // Helper arrays
        client: [ clientStub, iid ].filter(i => i !== undefined),
        server: [ proxy, serverStub, dllData, iid ].filter(i => i !== undefined),
    };

    return output;
}

function iff<T>(cond: boolean, val: T): T { return cond ? val : undefined; }

/**
 * This function evaluates all the arguments and creates the appropriate command line
 */
function evaluateArgs(args: Arguments, midlFile: MidlFile, dllData: File): MidlRunnerState {

    if (args.idlFile !== undefined && args.interfaceType === InterfaceType.winRT)
        Contract.fail("midlFile is a setting specific for Midl WinRt. Set the interface type to WinRt before continuing");
    
    if (midlFile.comProxyEntriesFileName !== undefined && (args.produce | IdlOutputs.comProxyEntries) === IdlOutputs.empty)
        Contract.warn("A file name was specified for the comProxyEntries but the runner is not set to produce the file.");
    
    if (midlFile.comProxyFileName !== undefined && (args.produce | IdlOutputs.comProxy) === IdlOutputs.empty)
        Contract.warn("A file name was specified for the comProxy but the runner is not set to produce the file.");
    
    if (midlFile.comUuidFileName !== undefined && (args.produce | IdlOutputs.comUuidConstants) === IdlOutputs.empty)
        Contract.warn("A file name was specified for the comUuid but the runner is not set to produce the file.");
    
    if (midlFile.headerFileName !== undefined && (args.produce | IdlOutputs.header) === IdlOutputs.empty)
        Contract.warn("A file name was specified for the header but the runner is not set to produce the file.");
    
    if (midlFile.oleTypeLibraryFileName !== undefined && (args.produce | IdlOutputs.oleAutomationTypeLibrary) === IdlOutputs.empty)
        Contract.warn("A file name was specified for the oleAutomationTypeLibrary but the runner is not set to produce the file.");
    
    if (midlFile.rpcClientFileName !== undefined && (args.produce | IdlOutputs.rpcClient) === IdlOutputs.empty)
        Contract.warn("A file name was specified for the rpcClient but the runner is not set to produce the file.");
    
    if (midlFile.rpcServerFileName !== undefined && (args.produce | IdlOutputs.rpcServer) === IdlOutputs.empty)
        Contract.warn("A file name was specified for the rpcServer but the runner is not set to produce the file.");
    
    if (midlFile.headerFileName !== undefined && (args.produce | IdlOutputs.header) === IdlOutputs.empty)
        Contract.warn("A file name was specified for the header but the runner is not set to produce the file.");
    
    if (midlFile.winRtMetadataFileName !== undefined && (args.produce | IdlOutputs.winRtMetadata) === IdlOutputs.empty)
        Contract.warn("A file name was specified for the winRtMetadata but the runner is not set to produce the file.");
    
    // Initialize the runner state

    let outputDirectory = Context.getNewOutputDirectory("midl");

    let executeArguments: Transformer.ExecuteArguments = {
        tool: args.tool || defaultTool(),
        tags: args.tags,
        arguments: [],
        dependencies: [],
        workingDirectory: Context.getSpecFileDirectory(),
    };

    let midlRunnerState: MidlRunnerState = {
        executeArguments: executeArguments,
        midlContext: {},
        outputDirectory: outputDirectory,
        dllData: dllData
    };

    // First we generate the non-trivial arguments (mainly enumerations which have a non-direct string translation)

    let includeDirectory: StaticDirectory = undefined;
    if (args.includesAndImports.length > 0) {
        includeDirectory = Transformer.sealPartialDirectory(Context.getSpecFileDirectory(), args.includesAndImports);
    }

    // Then we generate all the trivial arguments and concat them all into the command line
    let outputArguments: Argument[] = [

        // Pre response file arguments

        Cmd.flag("/nologo", args.suppressStartupBanner),
        Cmd.flag("/no_stamp", !args.timestampComment),
        Cmd.flag("/no_settings_comment", !args.compilerSettingsComment),
        Cmd.option("/out ", Artifact.none(outputDirectory)),

        // Response file arguments

        Cmd.startUsingResponseFile(false),

        //  Operating mode arguments

        Cmd.argument(Shared.mapEnumConst(args.operatingMode,
            [OperatingMode.defaultOption, "/ms_ext"],
            [OperatingMode.osfStrict, "/osf"],
            [OperatingMode.allowApplicationConfigurationKeywordsKeywords, "/app_config"],
            [OperatingMode.objectDefinitionLanguage, "/mktyplib203"])),

        // Includes arguments

        Cmd.option("/I ", Artifact.none(includeDirectory)),
        Cmd.options("/I ", Artifact.inputs(args.includeSearchPaths)),
        Cmd.flag("/no_def_idir", args.includeSearchPathBehavior === IncludeSearchPathBehavior.excludeSourcePath),

        // Data respresentation arguments

        Cmd.option("/Zp", Shared.mapEnumConst(args.structMemberAlignment,
            [MidlStructMemberAlignment.align1, "1"],
            [MidlStructMemberAlignment.align2, "2"],
            [MidlStructMemberAlignment.align4, "4"],
            [MidlStructMemberAlignment.align8, "8"])),

        Cmd.flag("/ms_union", args.nonEncapsulatedUnionBehavior === NonEncapsulatedUnionBehavior.legacy),
        Cmd.option("/char ", args.charBaseType.toString().toLowerCase(), args.charBaseType !== CharBaseType.defaultOption),

        // Marshaling arguments

        Cmd.option("/O", Shared.mapEnumConst(args.marshalingOptimization,
            [MarshalingOptimization.codeless,            "icf"],
            [MarshalingOptimization.codelessObsolete,    "s"],
            [MarshalingOptimization.interpretedObsolete, "ic"],
            [MarshalingOptimization.mixedMode,           "i"])),
        Cmd.flag("/no_format_opt", args.typeAndProcedureOptimization === TypeAndProcedureOptimization.none),
        Shared.mapEnumConstToArgument(args.networkDataRepresentationRuntimeChecking,
            [NetworkDataRepresentationRuntimeChecking.robust,                      Cmd.argument("/robust")],
            [NetworkDataRepresentationRuntimeChecking.none,                        Cmd.argument("/no_robust")],
            [NetworkDataRepresentationRuntimeChecking.noneLegacy,                  Cmd.option("/error ", "none")],
            [NetworkDataRepresentationRuntimeChecking.allocationLegacy,            Cmd.option("/error ", "allocation")],
            [NetworkDataRepresentationRuntimeChecking.unmarshallingFailuresLegacy, Cmd.option("/error ", "stub_data")],
            [NetworkDataRepresentationRuntimeChecking.nullReferencesLegacy,        Cmd.option("/error ", "ref")],
            [NetworkDataRepresentationRuntimeChecking.boundChecksLegacy,           Cmd.option("/error ", "bounds_check")],
            [NetworkDataRepresentationRuntimeChecking.allLegacy,                   Cmd.option("/error ", "all")]),

        Cmd.option("/protocol ", args.stubWireProtocol.toString().toLowerCase()),
        Cmd.flag("/rpcss", args.enableAllocateBehavior === EnableAllocateBehavior.inject),

        // Target arguments

        Cmd.option("/target ", args.minimumTargetOperatingSystem.toString().toUpperCase()),
        Cmd.option("/env ", (args.targetEnvironment === MidlTargetEnvironment.x64 ? "ia64" : args.targetEnvironment.toString().toLowerCase())),

        // Preprocessor arguments

        Cmd.options("/D ", args.preprocessorSymbols.map(pair => pair.name + (pair.value !== undefined ? "=" + pair.value : ""))),
        Cmd.options("/U ", args.undefinePreprocessorSymbols),
        (args.cPreprocessing && args.preprocessorOptions && args.preprocessorOptions.length > 0 ?
            Cmd.option("/cpp_opt ", args.preprocessorOptions.join(" ")) :
            undefined),
        (args.cPreprocessing ?
            Cmd.option("/cpp_cmd ", Artifact.none(args.cPreprocessor.exe)) :
            Cmd.argument("/no_cpp")),

        Cmd.argument(Shared.mapEnumConst(args.staticAnalysisOptions,
            [StaticAnalysisOption.none,                        ""],
            [StaticAnalysisOption.decorateStubMethods,         "/sal"],
            [StaticAnalysisOption.decorateLocalAndStubMethods, "/sal /sal_local"])),

        // Warning level arguments

        Cmd.option("/W", Shared.mapEnumConst(args.warningLevel,
            [MidlWarningLevel.turnOffAllWarnings, "0"],
            [MidlWarningLevel.level1, "1"],
            [MidlWarningLevel.level2, "2"],
            [MidlWarningLevel.level3, "3"],
            [MidlWarningLevel.level4, "4"])),
        Cmd.flag("/WX", args.treatWarningsAsErrors),

        // Miscellaneous arguments

        Cmd.flag("/oldnames", args.interfaceNameBehavior === InterfaceNameBehavior.legacy),
        Cmd.option("/lcid ", args.inputLocaleId, args.inputLocaleId !== 0),

        // WinRt arguments
        ...(args.interfaceType === InterfaceType.winRT ?
            [   Cmd.argument("/winrt"),
                Cmd.options("/metadata_dir ", Artifact.inputs(args.winRtMetadataDir)),
                Cmd.args(Shared.mapEnumFlags(args.winRtCodeGeneration,
                            [WinRtCodeGeneration.useEnumClass, "/enum_class"],
                            [WinRtCodeGeneration.useNsPrefix,  "/ns_prefix"],
                            [WinRtCodeGeneration.trueAsync,    "/enable_true_async true"],
                            [WinRtCodeGeneration.structByRef,  "/struct_by_ref"])) ] :
            []),
        (args.idlFile !== undefined ? Cmd.option("/idl_file", Artifact.output(Path.interpolate(outputDirectory, args.idlFile))) : undefined)
    ];

    midlRunnerState = midlRunnerState.override<MidlRunnerState>({
        executeArguments: midlRunnerState.executeArguments.merge<MidlRunnerState>({
            arguments: outputArguments
        })
    });

    // Then we add the complicated arguments for outputs
    midlRunnerState = evaluateOutputArguments(args, midlFile, midlRunnerState);

    midlRunnerState = midlRunnerState.override<MidlRunnerState>({
        executeArguments: midlRunnerState.executeArguments.merge<MidlRunnerState>({
            arguments: [
                Cmd.option("/acf ", Artifact.input(midlFile.applicationConfigurationFile), midlFile.applicationConfigurationFile !== undefined),
                Cmd.argument(Artifact.input(midlFile.source))
            ],
        })
    });

    return midlRunnerState;
}

/**
 * Evaluates the output arguments.
 * Returns an object with an array of the generated arguments and the MidlEvaluationContext
 */
function evaluateOutputArguments(
    args: Arguments,
    midlFile: MidlFile,
    midlRunnerState: MidlRunnerState): MidlRunnerState {
    let baseName: Path = midlFile.source.path.relocate(d`${midlFile.source.parent}`, midlRunnerState.outputDirectory, undefined);
    let cmdArgs: Argument[] = [];
    let implicitOutputs: Transformer.OutputArtifact[] = [];

    if (args.noMidl) {
        cmdArgs = cmdArgs.push(Cmd.argument("/nomidl"));
    } else {
        midlRunnerState = generateOutput(
            midlRunnerState,
            "/header",
            (args.produce & IdlOutputs.header) === IdlOutputs.header,
            midlFile !== undefined ? midlFile.headerFileName : undefined,
            baseName,
            "headerFile",
            a`.h`,
            undefined,
            "nul");

        switch(args.interfaceType) {
            case InterfaceType.winRT:
                midlRunnerState = evaluateOutputArgumentsWinRt(args, midlRunnerState, midlFile, baseName);
                // WinRt can also produce OLE specific output
            case InterfaceType.ole:
                midlRunnerState = evaluateOutputArgumentsOLE(args, midlRunnerState, midlFile, baseName);
                break;
            case InterfaceType.rpc:
                midlRunnerState = evaluateOutputArgumentsRPC(args, midlRunnerState, midlFile, baseName);
                break;
        }
    }

    if (args.mefFileGeneration) {
        let exportExtension: PathAtom = PathAtom.create("_export.mef");
        let mefFile = Path.interpolate(baseName, exportExtension);
        cmdArgs = cmdArgs.push(Cmd.argument("/export"));
        implicitOutputs = implicitOutputs.push(mefFile);
        midlRunnerState = midlRunnerState.override<MidlRunnerState>({
            midlContext: midlRunnerState.midlContext.overrideKey("mefFile", mefFile)
        });
    }

    midlRunnerState = midlRunnerState.override<MidlRunnerState>({
        executeArguments: midlRunnerState.executeArguments.merge<Transformer.ExecuteArguments>({
            arguments: cmdArgs,
            implicitOutputs: implicitOutputs
        })
    });

    return midlRunnerState;
}

/**
 * Evaluate the output arguments winRt
 */
function evaluateOutputArgumentsWinRt(
    args: Arguments,
    midlRunnerState: MidlRunnerState,
    midlFile: MidlFile,
    baseName: Path): MidlRunnerState {
    Contract.requires(midlRunnerState !== undefined);
    Contract.requires(midlRunnerState.midlContext !== undefined);
    Contract.requires(midlFile !== undefined);
    Contract.requires(baseName !== undefined);

    if ((args.produce & idlOutputsRpc) !== IdlOutputs.empty) {
        Contract.fail("The interface type " + args.interfaceType + " cannot generate the RPC output set in the Produce option " + args.produce + ".");
    }

    midlRunnerState = generateOutput(
        midlRunnerState,
        "/winmd",
        (args.produce & IdlOutputs.winRtMetadata) === IdlOutputs.winRtMetadata,
        (midlFile !== undefined ? midlFile.winRtMetadataFileName : undefined),
        baseName,
        "winRtMetadataFile",
        a`.winmd`,
        "/nomd"
    );

    return midlRunnerState;
}

/**
 * Evaluate the output arguments for OLE
 */
function evaluateOutputArgumentsOLE(
    args: Arguments,
    midlRunnerState: MidlRunnerState,
    midlFile: MidlFile,
    baseName: Path): MidlRunnerState {
    Contract.requires(midlRunnerState !== undefined);
    Contract.requires(midlRunnerState.midlContext !== undefined);
    Contract.requires(midlFile !== undefined);
    Contract.requires(baseName !== undefined);

    if ((args.produce & idlOutputsRpc) !== IdlOutputs.empty) {
        Contract.fail("The interface type " + args.interfaceType + " cannot generate the RPC output set in the Produce option specified.");
    }

    midlRunnerState = generateOutput(
        midlRunnerState,
        "/tlb",
        (args.produce & IdlOutputs.oleAutomationTypeLibrary) === IdlOutputs.oleAutomationTypeLibrary,
        (midlFile !== undefined ? midlFile.oleTypeLibraryFileName : undefined),
        baseName,
        "typeLibraryFile",
        a`.tlb`,
        "/notlb"
    );

    let defaultDllData = Path.interpolate(midlRunnerState.outputDirectory, "dlldata");

    midlRunnerState = generateDllDataOutput(
        midlRunnerState,
        (args.produce & IdlOutputs.comProxyEntries) === IdlOutputs.comProxyEntries,
        (midlFile !== undefined ? midlFile.comProxyEntriesFileName : undefined),
        defaultDllData,
        ".c",
        undefined,
        "nul"
    );

    midlRunnerState = generateOutput(
        midlRunnerState,
        "/iid",
        (args.produce & IdlOutputs.comUuidConstants) === IdlOutputs.comUuidConstants,
        (midlFile !== undefined ? midlFile.comUuidFileName : undefined),
        baseName,
        "iidFile",
        a`_i.c`,
        undefined,
        "nul"
    );

    midlRunnerState = generateOutput(
        midlRunnerState,
        "/proxy",
        (args.produce & IdlOutputs.comProxy) === IdlOutputs.comProxy,
        (midlFile !== undefined ? midlFile.comProxyFileName : undefined),
        baseName,
        "proxyFile",
        a`_p.c`,
        undefined,
        "nul"
    );

    return midlRunnerState;
}

/**
 * Evaluate the output arguments for RPC
 */
function evaluateOutputArgumentsRPC(
    args: Arguments,
    midlRunnerState: MidlRunnerState,
    midlFile: MidlFile,
    baseName: Path): MidlRunnerState {
    Contract.requires(midlRunnerState !== undefined);
    Contract.requires(midlRunnerState.midlContext !== undefined);
    Contract.requires(midlFile !== undefined);
    Contract.requires(baseName !== undefined);

    if ((args.produce & idlOutputsCom) !== IdlOutputs.empty) {
        Contract.fail("The interface type " + args.interfaceType + " cannot generate the OLE output set in the Produce option specified.");
    }

    if ((args.produce & idlOutputsWinRt) !== IdlOutputs.empty) {
        Contract.fail("The interface type " + args.interfaceType + " cannot generate the WinRt output set in the Produce option specified.");
    }

    midlRunnerState = generateOutput(
        midlRunnerState,
        "/cstub",
        (args.produce & IdlOutputs.rpcClient) === IdlOutputs.rpcClient,
        (midlFile !== undefined ? midlFile.rpcClientFileName : undefined),
        baseName,
        "clientStubFile",
        a`_c.c`,
        "/client",
        "none");

    midlRunnerState = generateOutput(
        midlRunnerState,
        "/sstub",
        (args.produce & IdlOutputs.rpcServer) === IdlOutputs.rpcServer,
        (midlFile !== undefined ? midlFile.rpcServerFileName : undefined),
        baseName,
        "serverStubFile",
        a`_s.c`,
        "/server",
        "none");

    let outputArguments: Argument[] = [ Cmd.argument(Shared.mapEnumConst(args.rpcServerEntryRoutingMethod,
                                                                        [ ServerStubEntryPoint.staticFunctions,                 undefined ],
                                                                        [ ServerStubEntryPoint.entryPointVectorNodefaultOption, "/use_epv" ],
                                                                        [ ServerStubEntryPoint.entryPointVector,                "/no_default_epv" ])) ];

    let produceClientStub: boolean = (args.produce & IdlOutputs.rpcClient) === IdlOutputs.rpcClient;
    let produceServerStub: boolean = (args.produce & IdlOutputs.rpcServer) === IdlOutputs.rpcServer;
    let server: string = args.rpcServerFunctionsPrefix !== undefined ? args.rpcServerFunctionsPrefix : args.rpcFunctionsPrefix;
    let client: string = args.rpcClientFunctionsPrefix !== undefined ? args.rpcClientFunctionsPrefix : args.rpcFunctionsPrefix;
    let prefixEmitted: boolean = false;

    if (produceClientStub && produceServerStub && server === client) {
        if (server !== undefined && server !== "") {
            outputArguments = outputArguments.concat(Cmd.args(["/prefix", "all", server]));
            prefixEmitted = true;
        }
    } else {
        if (produceClientStub && client !== undefined && client !== "") {
            outputArguments = outputArguments.concat(Cmd.args(["/prefix", "client", client]));
            prefixEmitted = true;
        }

        if (produceServerStub && server !== undefined && server !== "") {
            if (!prefixEmitted) {
                outputArguments = outputArguments.push(Cmd.argument("/prefix"));
                prefixEmitted = true;
            }

            outputArguments = outputArguments.concat(Cmd.args(["server", server]));
        }
    }

    if (args.switchRoutinesPrefix !== undefined && args.switchRoutinesPrefix !== "") {
        if (!prefixEmitted) {
            outputArguments = outputArguments.push(Cmd.argument("/prefix"));
            prefixEmitted = true;
        }

        outputArguments = outputArguments.concat(Cmd.args(["switch", args.switchRoutinesPrefix]));
    }

    // Enforce MIDL compiler to explicitly set /proxy nul /iid nul /dlldata nul /notlb for MIDL RPC interfaces
    outputArguments = outputArguments.concat([
        Cmd.option("/proxy ", "nul"),
        Cmd.option("/dlldata ", "nul"),
        Cmd.option("/iid ", "nul"),
        Cmd.argument("/notlb"),
    ]);

    midlRunnerState = midlRunnerState.override<MidlRunnerState>({
        executeArguments: midlRunnerState.executeArguments.merge<Transformer.ExecuteArguments>({
            arguments: outputArguments
        })
    });

    return midlRunnerState;
}

/**
 * Generate an output file
 */
function generateOutput(
    midlRunnerState: MidlRunnerState,
    argName: string,
    produce: boolean,
    fileName: PathAtom,
    defaultBaseName: Path,
    outputFileVariableName: string,
    defaultExtension?: PathAtom,
    absentCaseArgName?: string,
    absentCase?: string
    ): MidlRunnerState {
    Contract.requires(argName !== undefined && argName !== "");
    Contract.requires(defaultBaseName !== undefined);

    let outputFile: Path = undefined;
    let outputArguments: Argument[] = [];
    let implicitOutputs: Transformer.OutputArtifact[] = [];

    if (produce) {
        if (fileName !== undefined) {
            outputFile = Path.interpolate(midlRunnerState.outputDirectory, fileName);
            outputArguments = outputArguments.concat([
                Cmd.argument(argName),
                Cmd.argument(Artifact.output(outputFile))
            ]);
        } else {
            outputFile = defaultBaseName.changeExtension(defaultExtension);
            implicitOutputs = implicitOutputs.push(outputFile);
        }
    } else {
        outputArguments = outputArguments.concat([
            Cmd.argument(absentCaseArgName !== undefined && absentCaseArgName !== "" ? absentCaseArgName : argName),
            (absentCase !== undefined && absentCase !== "" ? Cmd.argument(absentCase) : undefined),
        ]);
    }

    return mergeMidlRunnerStates(
        midlRunnerState,
        <MidlRunnerState> {
            executeArguments: midlRunnerState.executeArguments.merge<Transformer.ExecuteArguments>({
                arguments: outputArguments,
                implicitOutputs: implicitOutputs,
            }),
            midlContext: midlRunnerState.midlContext.overrideKey(outputFileVariableName, outputFile)
        });
}

/**
 * Generate Dll data output
 */
function generateDllDataOutput(
    midlRunnerState: MidlRunnerState,
    produce: boolean,
    fileName: PathAtom,
    defaultBaseName: Path,
    defaultExtension?: string,
    absentCaseArgName?: string,
    absentCase?: string
    ): MidlRunnerState {
    Contract.requires(defaultBaseName !== undefined);

    let outputFile: File = undefined;
    let outputArguments: Argument[] = [];
    let implicitOutputs: Transformer.OutputArtifact[] = [];
    let keepOutputsWritable = false;

    if (produce) {
        if (fileName !== undefined) {
            outputFile = f`${midlRunnerState.outputDirectory}\${fileName}`;
            if (midlRunnerState.dllData !== undefined) {
                outputArguments = outputArguments.concat([
                    Cmd.argument("/dlldata"),
                    Cmd.argument(Artifact.rewritten(outputFile, midlRunnerState.dllData.path))
                ]);
            } else {
                outputArguments = outputArguments.concat([
                    Cmd.argument("/dlldata"),
                    Cmd.argument(Artifact.output(outputFile))
                ]);
            }
        } else {
            outputFile = f`${defaultBaseName.changeExtension(defaultExtension)}`;

            if (midlRunnerState.dllData !== undefined) {
                implicitOutputs = implicitOutputs.push(outputFile);
                keepOutputsWritable = true;
            } else {
                implicitOutputs = implicitOutputs.push(outputFile);
            }
        }
    } else {
        outputArguments = outputArguments.concat([
            Cmd.argument(absentCaseArgName !== undefined && absentCaseArgName !== "" ? absentCaseArgName : "/dlldata"),
            (absentCase !== undefined && absentCase !== "" ? Cmd.argument(absentCase) : undefined),
        ]);
    }

    return mergeMidlRunnerStates(
        midlRunnerState,
        <MidlRunnerState> {
            executeArguments: midlRunnerState.executeArguments.merge<Transformer.ExecuteArguments>({
                arguments: outputArguments,
                implicitOutputs: implicitOutputs,
                keepOutputsWritable: keepOutputsWritable
            }),
            midlContext: midlRunnerState.midlContext.overrideKey("dllDataFile", outputFile)
        });
}

/**
 * Controls what char equates to for the generated header, so that it can be
 * consistant with the C/C++ compiler's concept of char and small.
 */
@@public
export const enum CharBaseType {
    /** Do not emit a specific sign specification on specify undecorated char values. */
    @@Tool.option("/char ascii7")
    ascii7,
    /** Default */
    defaultOption,
    /** Treat all char types not accompanied by a sign specification as signed */
    @@Tool.option("/char signed")
    signed,
    /** Treat all char types not accompanied by a sign specification as unsigned */
    @@Tool.option("/char unsigned")
    unsigned
}

/**
 * Global behavior with regards to the enable_allocate attribute.
 */
@@public
export const enum EnableAllocateBehavior {
    /** Only enable the RpcSs package where the enable_allocate attributes is explicitly specified. */
    defaultOption,
    /**
     * Acts as though the enable_allocate attribute was specified on all operations of the interface.
     * Not recommended.
     */
    @@Tool.option("/rpcss")
    inject
}

/**
 * The IDL generated output files.
 */
@@public
export const enum IdlOutputs {
    /** The empty enum value */
    empty = 0x0,
    // Value 0x01 is reserved for IDL

    /** The C header file */
    header = 0x2,
    /** The RPC client C file */
    rpcClient = 0x4,
    /** The RPC server C file */
    rpcServer = 0x8,
    /**
     * The OLE/COM proxy file
     * The _p.c file which contains the OLE proxy implementation
     */
    comProxy = 0x10,
    /**
     * The OLE/COM dll entry and data structures for the proxy dll
     * The dlldata file contains entry points and data structures required by the class factory for the proxy DLL.
     */
    comProxyEntries = 0x20,
    /** The OLE/COM proxy and dlldata file. */
    comProxyDll = 0x30, // comProxy | comProxyEntries
    /** The OLE/COM Universal Unique Identifiers file. */
    comUuidConstants = 0x40,
    /** The OLE automation type library file */
    oleAutomationTypeLibrary = 0x80,
    /** WinRt metadata file. */
    winRtMetadata = 0x100
}

/**
 * Use or ignore the source IDL directory implicitly in the include search.
 */
@@public
export const enum IncludeSearchPathBehavior {
    /** Use the source IDL directory implicitly in the include search. */
    defaultOption,
    /** Ignore the source IDL directory implicitly in the include search. */
    @@Tool.option("/no_def_dir")
    excludeSourcePath
}

/**
 * The autogeneration behavior for interface names.
 */
@@public
export const enum InterfaceNameBehavior {
    /** Match the behavior of the OSF-DCE IDL compiler. */
    defaultOption,
    /**
     * Do not include the version number in the interfaces names.
     * For backwards compatiblity with MIDL 1.0, this should be false.
     */
    @@Tool.option("/oldnames")
    legacy
}

/**
 * Declares the type of content expressed in the source file.
 * Interface definition language (IDL) files can be used to express multiple types of contracts.  From Object Linking and Embedding (OLE) to WinRT interfaces.
 * Since the set of files produce by the tool are different, the correct type must be selected to correctly track which output files will be generated.
 */
@@public
export const enum InterfaceType {
    /** The source file contains an interface (or interfaces) to be used with COM, OLE or OLE Automation. */
    ole,
    /** The source file contains C method to represent some Remote Procedure Call abstraction between client and server. */
    rpc,
    /** The source file contains interface definitions for objects to conform to the Windows Runtime standard. */
    winRT
}

/**
 * Determines how strict the compiler should be about warnings.
 */
@@public
export const enum IntPtrType {
    /** Default behavior. */
    defaultOption,
    /** Use VT_INT_PTR to for int_ptr types.  Not supported in old type library versions. */
    @@Tool.option("/use_vt_int_ptr")
    variantTypeIntPtr
}

/**
 * The form of Marshaling optionation to apply for generated stubs and proxy.
 */
@@public
export const enum MarshalingOptimization {
    /** Generate fully interpreted stubs with extensions and stubless proxies for object interfaces as of NT 4.0 release (default). */
    @@Tool.option("/Oicf")
    codeless,
    /** Generate fully interpreted stubs for standard interfaces and stubless proxies for object interfaces as of NT 3.51 release using -Oicf instead is usually better */
    @@Tool.option("/Oic")
    codelessObsolete,
    /** Generate fully interpreted stubs, old style -Oicf is usually better */
    @@Tool.option("/Oi")
    interpretedObsolete,
    /** Use a mixed-mode method to marshal stub code passed between client and server. */
    @@Tool.option("/Os")
    mixedMode
}

/**
 * Controls the boundary for struct member alignment.
 */
@@public
export const enum MidlStructMemberAlignment {
    /** Packs structures on 1-byte boundaries. */
    @@Tool.option("/Zp1")
    align1,
    /** Packs structures on 2-byte boundaries. */
    @@Tool.option("/Zp2")
    align2,
    /** Packs structures on 4-byte boundaries. */
    @@Tool.option("/Zp4")
    align4,
    /** Packs structures on 8-byte boundaries. */
    @@Tool.option("/Zp8")
    align8
}

/**
 * Indicates the type of machine that the proxy/stubs will run on.
 */
@@public
export const enum MidlTargetEnvironment {
    /** Target environment is an Advanced Micro Devices 64-bit (AMD4). */
    @@Tool.option("/env amd64")
    @@Tool.option("/amd64")
    amd64,
    /** Target environment is Microsoft Windows for 32-bit ARM Systems. Not documented in MSDN. */
    @@Tool.option("/env arm32")
    @@Tool.option("/arm32")
    arm32,
    /** Target environment is Microsoft Windows for 64-bit ARM Systems. Not documented in MSDN. */
    @@Tool.option("/env arm64")
    @@Tool.option("/arm64")
    arm64,
    /** Target environment is Microsoft Windows 32-bit (NT). */
    @@Tool.option("/env win32")
    @@Tool.option("/win32")
    win32,
    /** Target environment is Microsoft Windows 64-bit (NT) running on Intel Architecture (IA64). */
    @@Tool.option("/env win64")
    @@Tool.option("/win64")
    win64,
    /** Target environment is Microsoft Windows for 64-Bit Extended Systems. */
    @@Tool.option("/env ia64")
    @@Tool.option("/ia64")
    x64
}

/**
 * Determines how strict the compiler should be about warnings.
 */
@@public
export const enum MidlWarningLevel {
    /** Turns off emission of all warning messages. */
    @@Tool.option("/W0")
    turnOffAllWarnings,
    /** Displays severe warning messages. */
    @@Tool.option("/W1")
    level1,
    /** Displays level 1 warnings plus some less-severe warnings. */
    @@Tool.option("/W2")
    level2,
    /** Reserved. */
    @@Tool.option("/W3")
    level3,
    /** Displays all level 3 warnings plus informational warnings. */
    @@Tool.option("/W4")
    level4
}

/**
 * A hint about the minimum operating system that the stubs will run on.
 * These just activate other switches and control which attributes are allowed in the idl file.
 */
@@public
export const enum MinimumTargetOperatingSystem {
    /**
     * Windows 2000.
     * For proxy/stub generation this equates to MarshalingOptimization = Codeless, NetworkDataRepresentationRuntimeChecking = true, though 64-bit support is disabled seealso Nt51
     * For interface definitions this enables [message], [async], [async_uuid], [notify] and [encode]/[decode].
     */
    @@Tool.option("/target NT50")
    nt50,

    /**
     * Windows XP.
     * For proxy/stub generation this equates to MarshalingOptimization = Codeless, NetworkDataRepresentationRuntimeChecking = true, StubWireProtocol= All and support for 64-bit.
     * For interface definitions this enables all the features from Nt50 plus [partial_ignore] and [force_allocate].
     */
    @@Tool.option("/target NT51")
    nt51,

    /**
     * Windows Vista.
     * For proxy/stub generation this equates to MarshalingOptimization = Codeless, NetworkDataRepresentationRuntimeChecking = true, StubWireProtocol= All
     * For interface definitions this enables all the features from Nt51 plus [range] and [type_strict_context_handle]. This also enables support for
     * context handles in an array or struct and forcing complex structure marshaling support.
     */
    @@Tool.option("/target NT60")
    nt60,

    /**
     * Windows 7.
     * For proxy/stub generation this equates to MarshalingOptimization = Codeless, NetworkDataRepresentationRuntimeChecking = true, StubWireProtocol= All
     * For interface definitions this enables all the features from Nt60 plus adds the requirement that for COM stub calls for interfaces with less than 32 methods require
     * linking to the COM stubs with OLE32.dll
     */
    @@Tool.option("/target NT61")
    nt61,

    /**
     * Windows 8.
     * For proxy/stub generation this equates to MarshalingOptimization = Codeless, NetworkDataRepresentationRuntimeChecking = true, StubWireProtocol= All and adds support for
     * ARM and WinRT.
     * For interface definitions this enables all the features from Nt61.
     */
    @@Tool.option("/target NT62")
    nt62,

    /**
     * Windows 10.
     * For proxy/stub generation this equates to MarshalingOptimization = Codeless, NetworkDataRepresentationRuntimeChecking = true, StubWireProtocol= All and adds support for
     * ARM and WinRT.
     * For interface definitions this enables all the features from Nt62.
     */
    @@Tool.option("/target NT100")
    nt100
}

/**
 * Generate additional data for the NDR engine so that it can perform runtime checking.
 */
@@public
export const enum NetworkDataRepresentationRuntimeChecking {
    /**
     * Turns on all legacy checks.
     * Obsolete, use Robust.
     */
    @@Tool.option("/error all")
    allLegacy,
    /**
     * Check whether midl_user_allocate returns a NULL value, indicating out-of-memory.
     * Obsolete, use Robust.
     */
    @@Tool.option("/error allocation")
    allocationLegacy,
    /**
     * Checks the size of conformant-varying and varying arrays against transmission length specification.
     * Obsolete, use Robust.
     */
    @@Tool.option("/error bounds_check")
    boundChecksLegacy,
    /** Perform no error checking. */
    @@Tool.option("/no_robust")
    none,
    /** Perform no error checking. */
    @@Tool.option("/error none")
    noneLegacy,
    /**
     * Check that no NULL reference pointers are being passed to the client stubs.
     * Obsolete, use Robust.
     * When a NULL reference happens, a RPC_X_NULL_REF_POINTER exception is raised.
     */
    @@Tool.option("/error ref")
    nullReferencesLegacy,
    /**
     * Allow the NDR engine to perform runtime checking on marshaled arguments, and interface pointers.
     * This is the default.
     */
    @@Tool.option("/robust")
    robust,
    /**
     * Catch any unmarshalling exceptions in the server stub and propagates them back to the client.
     * Obsolete, use Robust.
     */
    @@Tool.option("/error stub_data")
    unmarshallingFailuresLegacy
}

/**
 * The NDR alignment behaviour for non-encapsulated unions.
 */
@@public
export const enum NonEncapsulatedUnionBehavior {
    /**
     * Match the behavior of the OSF-DCE IDL compiler.
     */
    defaultOption,
    /**
     * Use Midl 1.0 non-DCE wire layout for non-encapsulated unions.
     */
    @@Tool.option("/ms_union")
    legacy
}

/**
 * Control the parsing logic dialic supported.
 */
@@public
export const enum OperatingMode {
    /** Allow application configuration keywords in the IDL file as well as Microsoft Extensions. */
    @@Tool.option("/app_config")
    allowApplicationConfigurationKeywordsKeywords,
    /** Allows for Microsoft Extensions in the IDL Language and File. */
    @@Tool.option("/ms_ext")
    defaultOption,
    /**
     * Legacy ODL (mktyplib203) mode.
     * This allows MIDL to act as a replacement for the ODL compiler (initial OLE Automation implementations).
     */
    @@Tool.option("/mktyplib203")
    objectDefinitionLanguage,
    /** Force strict compatibility with OSF DCE. */
    @@Tool.option("/osf")
    osfStrict
}

/**
 * Control over how the server stub routes function calls to an implementation.
 */
@@public
export const enum ServerStubEntryPoint {
    /** The server stub call will route to the implementation by use of a entry-point vector. */
    @@Tool.option("/use_epv")
    entryPointVector,
    /**
     * The server stub call will route to the implementation by use of a entry-point vector,
     * but there will be no default implementation generated.
     */
    @@Tool.option("/no_default_epv")
    entryPointVectorNodefaultOption,
    /** The server stub call will route to the implementation by use of a static function. */
    staticFunctions
}

/**
 * Options to generate Static analysis annotations on generated code.
 */
@@public
export const enum StaticAnalysisOption {
    /** Generate SAL annotations for parameters of interface methods marked [local] as well as in generated stub files. */
    @@Tool.option("/sal_local")
    decorateLocalAndStubMethods,

    /** Generate SAL annotations in the generated stub files. */
    @@Tool.option("/sal")
    decorateStubMethods,

    /** The server stub call will route to the implementation by use of a static function. */
    none
}

/**
 * The type of wire protocol that the stub should support.
 */
@@public
export const enum StubWireProtocol {
    /** Creates a stub that may use any available wire protocol. */
    @@Tool.option("/protocol all")
    all,
    /** Creates a stub that only supports the DCE wire protocol. */
    @@Tool.option("/protocol dce")
    dce,
    /** Creates a stub that only supports the ndr64 wire protocol. */
    @@Tool.option("/protocol ndr64")
    ndr64
}

/**
 * Optimization settings for type and procedure descriptors.
 */
@@public
export const enum TypeAndProcedureOptimization {
    /** Eliminate duplicate type and procedure descriptors in order to reduce the size of the generated stub code. */
    foldDuplicates,
    /** Suppress optimization behavior. */
    @@Tool.option("/no_format_opt")
    none
}

/**
 * The format to use when generating an OLE Automation Type Library.
 */
@@public
export const enum TypeLibrary {
    /** Generate type library. */
    defaultOption,
    /** Generate old format type library. */
    legacyFormat
}

/**
 * Flags specific to WinRt code generation in Midl
 */
@@public
export const enum WinRtCodeGeneration {
    /** Empty enum for flag */
    empty = 0x0,

    /** Enable use of the C++ enum class construct. */
    @@Tool.option("/enum_class")
    useEnumClass = 0x1,
    /** Generate metadata while processing windows runtime IDL file. */
    @@Tool.option("/nomd")
    generateWinRtMetadata = 0x2,
    /** Prepends the "ABI" prefix to all types. */
    @@Tool.option("/ns_prefix")
    useNsPrefix = 0x4,
    /** Enables true async feature. */
    @@Tool.option("/enable_true_async")
    trueAsync = 0x8,
    /** Enforces strict version checks. */
    @@Tool.option("/enforce_version")
    enforceVersion = 0x10,
    /** Enables the “by ref struct” feature. */
    @@Tool.option("/struct_by_ref")
    structByRef = 0x20
}
