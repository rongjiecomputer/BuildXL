// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Diagnostics.ContractsLight;
using System.Globalization;
using System.Linq;
using System.Text;
using BuildXL.Cache.ContentStore.Interfaces.Logging;
using BuildXL.Utilities;

namespace BuildXL.Cache.ContentStore.Logging
{
    /// <summary>
    ///     Like <see cref="FileLog"/> except that it produces a valid CSV file.
    /// </summary>
    public sealed class CsvFileLog : FileLog
    {
        /// <summary>
        ///     Types of supported columns for the output CSV file
        /// </summary>
        public enum ColumnKind
        {
            /// <summary>
            ///     Empty string.
            /// </summary>
            Empty,

            /// <summary>
            ///     A GUID that is either explicitly provided or autogenerated by the log object (<see cref="CsvFileLog.BuildId"/>)
            /// </summary>
            BuildId,

            /// <summary>
            ///     Name of the host machine
            /// </summary>
            Machine,

            /// <summary>
            ///     Timestamp of the message in UTC.
            /// </summary>
            PreciseTimeStamp,

            /// <summary>
            ///     Timestamp of the message in local time.
            /// </summary>
            LocalPreciseTimeStamp,

            /// <summary>
            ///     The id of the thread logging the message
            /// </summary>
            ThreadId,

            /// <summary>
            ///     The id of the process logging the message
            /// </summary>
            ProcessId,

            /// <summary>
            ///     Ordinal representation of <see cref="Severity"/>
            /// </summary>
            LogLevel,

            /// <summary>
            ///     Friendly string representation of <see cref="Severity"/>
            /// </summary>
            LogLevelFriendly,

            /// <summary>
            ///     Name of the service using this log (<see cref="CsvFileLog.Service"/>)
            /// </summary>
            Service,

            /// <summary>
            ///     Message to log
            /// </summary>
            Message,

            /// <summary>
            ///     Operating system platform (<see cref="OperatingSystem.Platform"/>)
            /// </summary>
            env_os,

            /// <summary>
            ///     Operating system version (<see cref="OperatingSystem.Version"/>)
            /// </summary>
            env_osVer
        }

        // case-insensitive mapping of ColumKind enum name to enum value
        private static Dictionary<string, ColumnKind> ColumnName2ValueMap = typeof(ColumnKind)
            .GetEnumNames()
            .ToDictionary
                (
                enumName => enumName,
                enumName => (ColumnKind)Enum.Parse(typeof(ColumnKind), enumName),
                StringComparer.OrdinalIgnoreCase
                );

        private readonly ColumnKind[] _schema;

        /// <summary>
        ///     Name of the service using this log.
        /// </summary>
        public string Service { get; }

        /// <summary>
        ///     Host name.
        /// </summary>
        public string Machine { get; }

        /// <summary>
        ///     Unique identifier of this log object.
        /// </summary>
        public Guid BuildId { get; }

        /// <summary>
        ///     Parses a string-formatted table name and returns a corresponding array of <see cref="ColumnKind"/>.
        ///
        ///     The expected string format is:
        ///
        ///         ColName[:ColType](, ColName[:ColType])*
        ///
        ///     ColName is a string identifier, i.e., any string that doesn't contain either ',' or ':'.
        ///
        ///     ColType is ignored.
        ///
        ///     Each ColName is mapped to a <see cref="ColumnKind"/> enum constant.  The value of ColName is
        ///     first matched against the names of <see cref="ColumnKind"/> enum constants (using the
        ///     case-insensitive string comparer).  If a match is found, the value is mapped to that enum
        ///     constant; otherwise, it is mapped to <see cref="ColumnKind.Empty"/>
        /// </summary>
        public static ColumnKind[] ParseTableSchema(string kustoTableSchema)
        {
            if (string.IsNullOrWhiteSpace(kustoTableSchema))
            {
                return new ColumnKind[0];
            }

            return kustoTableSchema.Trim()
                .Split(',')
                .Select(col => col.Split(':').First().Trim())
                .Select(colName => GetValueOrDefault(ColumnName2ValueMap, colName, ColumnKind.Empty))
                .ToArray();
        }

        private static TV GetValueOrDefault<TK, TV>(Dictionary<TK, TV> dict, TK key, TV defaultValue)
        {
            return dict.TryGetValue(key, out var value)
                ? value
                : defaultValue;
        }

        /// <summary>
        ///     Constructor.  Initializes this object and does nothing else.
        /// </summary>
        /// <param name="logFilePath">Full path to log file</param>
        /// <param name="schema">CSV schema as a list of columns. Each element in the list denotes a column to be rendered at that position.</param>
        /// <param name="severity">Minimum severity to log</param>
        /// <param name="maxFileSize">Maximum size of the log file.</param>
        /// <param name="serviceName">Name of the service using this log.  Used to render <see cref="ColumnKind.Service"/></param>
        /// <param name="buildId">A uniqu build identifier.  Used to render <see cref="ColumnKind.BuildId"/></param>
        public CsvFileLog
            (
            string logFilePath,
            IEnumerable<ColumnKind> schema,
            Severity severity = Severity.Diagnostic,
            long maxFileSize = 0,
            string serviceName = null,
            Guid buildId = default
            )
            :
            base
                (
                logFilePath,
                severity,
                autoFlush: true,
                maxFileSize: maxFileSize,
                maxFileCount: 0 // unlimited
                )
        {
            Contract.Requires(schema != null);

            _schema = schema.ToArray();
            Service = CsvEscape(serviceName ?? string.Empty);
            Machine = CsvEscape(Environment.MachineName);
            BuildId = buildId == default ? Guid.NewGuid() : buildId;
        }

        /// <summary>
        ///     Logs a message to the underlying CSV file according to the schema passed to the constructor of this object.
        /// </summary>
        public override void Write(DateTime dateTime, int threadId, Severity severity, string message)
        {
            if (severity < CurrentSeverity)
            {
                return;
            }

            using (var stringBuilderPool = Pools.StringBuilderPool.GetInstance())
            {
                StringBuilder line = stringBuilderPool.Instance;
                RenderMessage(line, dateTime, threadId, severity, message);
                WriteLineInternal(severity, line.ToString());
            }
        }

        /// <nodoc />
        public void RenderMessage(StringBuilder line, DateTime dateTime, int threadId, Severity severity, string message)
        {
            foreach (var col in _schema)
            {
                if (line.Length > 0)
                {
                    line.Append(",");
                }

                line.Append('"');
                line.Append(RenderColumn(col, dateTime, threadId, severity, message));
                line.Append('"');
            }
        }

        /// <nodoc />
        public string RenderColumn(ColumnKind col, DateTime dateTime, int threadId, Severity severity, string message)
        {
            switch (col)
            {
                case ColumnKind.Empty:
                    return string.Empty;
                case ColumnKind.BuildId:
                    return BuildId.ToString();
                case ColumnKind.Machine:
                    return Machine;
                case ColumnKind.PreciseTimeStamp:
                    return FormatTimeStamp(dateTime.ToUniversalTime());
                case ColumnKind.LocalPreciseTimeStamp:
                    return FormatTimeStamp(dateTime.ToLocalTime());
                case ColumnKind.ThreadId:
                    return threadId.ToString();
                case ColumnKind.ProcessId:
                    return System.Diagnostics.Process.GetCurrentProcess().Id.ToString();
                case ColumnKind.LogLevel:
                    return ((int)severity).ToString();
                case ColumnKind.LogLevelFriendly:
                    return severity.ToString();
                case ColumnKind.Service:
                    return Service;
                case ColumnKind.Message:
                    return CsvEscape(message);
                case ColumnKind.env_os:
                    return Environment.OSVersion.Platform.ToString();
                case ColumnKind.env_osVer:
                    return Environment.OSVersion.Version.ToString();
                default:
                    throw Contract.AssertFailure("Unknown column type: " + col);
            }
        }

        private string FormatTimeStamp(DateTime dateTime)
        {
            return string.Format(CultureInfo.InvariantCulture, "{0:yyyy-MM-dd HH:mm:ss.fff}", dateTime);
        }

        private string CsvEscape(string str)
        {
            return str.Replace("\"", "\"\"");
        }
    }
}
